# import torch
import random
import pygame
import sys
import os
import event_manager as em
import Storyline

random.seed()

# Init bg
bg_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Background")
pic_location = os.path.join(bg_folder, 'Solarite_bg.png')
bgso = pygame.image.load(pic_location)

pygame.init()

SCREEN_WIDTH = 500
SCREEN_HEIGHT = 320
TILE_SIZE = 24
GROUND_Y_OFFSET = 15

bgso = pygame.transform.scale(bgso, (SCREEN_WIDTH, SCREEN_HEIGHT))

GRAVITY = 1.156789123456789123456789
JUMP_STRENGTH = 16.456
player_speed = 4

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Forgebound: Rise of the Starforge")
solarite_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Solarite")
cryon_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Cryon")
voidstone_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Voidstone")
gravium_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Gravium")
toxic_swamps_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Toxic Swamps")
player_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Player", "Normal")

# INIT PLAYER1
player1_location = os.path.join(player_folder, 'player1.png')
player1_img = pygame.image.load(player1_location).convert_alpha()
player1_img = pygame.transform.scale(player1_img, (TILE_SIZE, TILE_SIZE*2))
player1_surf = player1_img

# Normal block
block1_location = os.path.join(solarite_terrain_folder, 'normal_block_solarite.png')
block_img = pygame.image.load(block1_location).convert_alpha()
block_img = pygame.transform.scale(block_img, (TILE_SIZE, TILE_SIZE))
block_surf = block_img

# Lava
lava_location = os.path.join(solarite_terrain_folder, 'lava_block.png')
lava_img = pygame.image.load(lava_location).convert_alpha()
lava_img = pygame.transform.scale(lava_img, (32, 16))
lava_surf = lava_img

# Spike
spike_loc = os.path.join(solarite_terrain_folder, 'spike_solarite.png')
spike_img = pygame.image.load(spike_loc).convert_alpha()
spike_img = pygame.transform.scale(spike_img, (TILE_SIZE, TILE_SIZE * 2))
spike_surf = spike_img

tall_block_surf = pygame.Surface((TILE_SIZE, TILE_SIZE * 2)); tall_block_surf.fill((100, 255, 100))
enemy_surf = pygame.Surface((TILE_SIZE, TILE_SIZE)); enemy_surf.fill((255, 0, 255))
start_surf = pygame.Surface((TILE_SIZE, TILE_SIZE)); start_surf.fill((0, 255, 255))
end_surf = pygame.Surface((TILE_SIZE, TILE_SIZE)); end_surf.fill((255, 255, 0))

TERRAIN = ['block', 'lava', 'spike', 'tall_block', 'enemy']
SEQUENCE_LENGTH = 20
levels_completed = 0

def generate_level():
    level = [''] * SEQUENCE_LENGTH
    level[0] = 'start'
    level[-1] = 'end'
    count = 0

    while True:
        start = random.randint(1, SEQUENCE_LENGTH - 4)
        if all(level[start + i] == '' for i in range(3)):
            for i in range(3):
                level[start + i] = 'block'
                count += 1
            break

    while True:
        start = random.randint(1, SEQUENCE_LENGTH - 4)
        if all(cell == '' for cell in level[start:start + 3]):
            for i in range(3):
                level[start + i] = 'tall_block'
            break

    for i in range(2, SEQUENCE_LENGTH - 2):
        if level[i - 1] == '' and level[i] == '' and level[i + 1] == '':
            level[i - 1] = 'block'
            level[i] = 'lava'
            level[i + 1] = 'block'
            count += 2
            break

    num_spikes = random.randint(1, 4)
    while True:
        start = random.randint(1, SEQUENCE_LENGTH - num_spikes - 1)
        if all(level[start + i] == '' for i in range(num_spikes)):
            for i in range(num_spikes):
                level[start + i] = 'spike'
            break

    for i in range(SEQUENCE_LENGTH):
        if level[i] == '':
            level[i] = 'block'
            count += 1

    max_enemies = count // 3
    enemy_count = 0
    attempts = 0

    def is_enemy_nearby(level, pos, range_=2):
        start = max(0, pos - range_)
        end = min(SEQUENCE_LENGTH, pos + range_ + 1)
        return any(level[i] == 'enemy' for i in range(start, end) if i != pos)

    while enemy_count < max_enemies and attempts < 100:
        pos = random.randint(3, SEQUENCE_LENGTH - 3)
        if (level[pos] == 'block' and
            level[pos - 1] == 'block' and
            level[pos + 1] == 'block' and
            not is_enemy_nearby(level, pos, range_=2)):
            level[pos] = 'enemy'
            enemy_count += 1
        attempts += 1

    return level

def find_starting_block():
    for i, tile in enumerate(level):
        if tile in ('start', 'block', 'tall_block'):
            tile_x = i * TILE_SIZE
            tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
            if tile in ('block', 'start'):
                return pygame.Rect(tile_x, tile_y - TILE_SIZE, TILE_SIZE, TILE_SIZE)
            elif tile == 'tall_block':
                return pygame.Rect(tile_x, tile_y - TILE_SIZE * 2, TILE_SIZE, TILE_SIZE)

def spawn_enemies():
    enemies.clear()
    for i, tile in enumerate(level):
        if tile == 'enemy':
            x = i * TILE_SIZE
            y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET - TILE_SIZE // 2
            rect = pygame.Rect(x, y, TILE_SIZE, TILE_SIZE)
            enemies.append({'rect': rect, 'dir': 1, 'origin_x': x})

# --- New Particle class for shatter effect ---
class Particle:
    def __init__(self, x, y, size):
        self.rect = pygame.Rect(x, y, size, size)
        self.vel_x = random.uniform(-4, 4)
        self.vel_y = random.uniform(-8, -2)
        self.size = size
        self.lifetime = 60  # frames
        self.gravity = 0.5

    def update(self):
        self.vel_y += self.gravity
        self.rect.x += int(self.vel_x)
        self.rect.y += int(self.vel_y)

        # Bounce off floor
        floor_y = SCREEN_HEIGHT - GROUND_Y_OFFSET
        if self.rect.bottom >= floor_y:
            self.rect.bottom = floor_y
            self.vel_y = -self.vel_y * 0.6  # bounce damping
            self.vel_x *= 0.8  # friction

        self.lifetime -= 1

    def draw(self, surface):
        pygame.draw.rect(surface, (255, 124, 200), self.rect)

# --- Globals for shatter animation ---
particles = []
shatter_animating = False


class Bubble:
    def __init__(self):
        self.reset()

    def reset(self):
        self.x = random.randint(0, SCREEN_WIDTH)
        self.y = random.randint(SCREEN_HEIGHT, SCREEN_HEIGHT + 200)
        self.radius = random.randint(3, 6)  # smaller, pixel-like
        self.speed = random.uniform(1, 2)
        self.color = random.choice(BUBBLE_COLORS)

    def update(self):
        self.y -= self.speed
        if self.y + self.radius < 0:
            self.reset()

    def draw(self, surface):
        pygame.draw.circle(surface, self.color, (int(self.x), int(self.y)), self.radius)

# --- Globals for lava animation ---
BUBBLE_COLORS = [(255, 223, 0), (255, 165, 0)]  # yellow & orange shades
bubbles = [Bubble() for _ in range(40)]
bubbles_animating = False  # flag for bubble animation active




level = generate_level()
LEVEL_WIDTH = len(level) * TILE_SIZE
enemies = []
spawn_enemies()
player = find_starting_block()
player_vel_y = 0
on_ground = False
scroll_x = 0
dead = False
death_phase = None
death_timer = 0
fade_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
fade_surface.fill((0, 0, 0))
fade_alpha = 0
show_player = True

clock = pygame.time.Clock()
running = True
while running:
    clock.tick(60)
    screen.blit(bgso, [0, 0])

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    keys = pygame.key.get_pressed()

    # --- Update particles if shatter anim is active ---
    if shatter_animating:
        fade_surface.set_alpha(150)
        screen.blit(fade_surface, (0, 0))

        for p in particles[:]:
            p.update()
            p.draw(screen)
            if p.lifetime <= 0:
                particles.remove(p)

        if not particles:
            # Reset after shatter animation ends
            shatter_animating = False
            dead = False
            player = find_starting_block()
            player_vel_y = 0
            spawn_enemies()
            scroll_x = 0
            continue

    if bubbles_animating:
        fade_surface.set_alpha(150)
        screen.blit(fade_surface, (0, 0))

        for bubble in bubbles:
            bubble.update()
            bubble.draw(screen)

    # When all bubbles have risen offscreen, end animation
    # We can check if all bubbles y + radius < 0
        if all(bubble.y + bubble.radius < 0 for bubble in bubbles):
            bubbles_animating = False
            dead = False
            player = find_starting_block()
            player_vel_y = 0
            spawn_enemies()
            scroll_x = 0

    



    else:
        if dead:
            player_vel_y = 0
            death_timer += 1

            if death_phase is None:
                death_phase = 'fade'
                death_timer = 0
                fade_alpha = 0

            if death_phase == 'fade':
                fade_alpha = min(255, fade_alpha + 10)
                if fade_alpha >= 255:
                    death_phase = 'pause'
                    death_timer = 0

            elif death_phase == 'pause':
                if death_timer >= 30:
                    death_phase = 'scroll'
                    death_timer = 0
                    fade_alpha = 255

            elif death_phase == 'scroll':
                scroll_x -= 5
                scroll_x = max(0, scroll_x)
                show_player = (death_timer // 5) % 2 == 0
                if scroll_x == 0:
                    death_phase = 'reset'
                    death_timer = 0

            elif death_phase == 'reset':
                player = find_starting_block()
                player_vel_y = 0
                dead = False
                death_phase = None
                death_timer = 0
                show_player = True

        else:
            move_x = 0
            if keys[pygame.K_LEFT]:
                move_x = -player_speed
            if keys[pygame.K_RIGHT]:
                move_x = player_speed

            player.x += move_x
            player.y += player_vel_y
            player_vel_y += GRAVITY
            on_ground = False

            for i, tile in enumerate(level):
                tile_x = i * TILE_SIZE
                tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
                if tile in ('block', 'start', 'end'):
                    tile_rect = pygame.Rect(tile_x, tile_y, TILE_SIZE, TILE_SIZE)
                elif tile == 'tall_block':
                    tile_rect = pygame.Rect(tile_x, tile_y - TILE_SIZE, TILE_SIZE, TILE_SIZE * 2)
                else:
                    continue
                if player.colliderect(tile_rect):
                    if player_vel_y > 0 and player.bottom <= tile_rect.top + player_vel_y:
                        player.bottom = tile_rect.top
                        player_vel_y = 0
                        on_ground = True
                    elif player_vel_y < 0 and player.top >= tile_rect.bottom - player_vel_y:
                        player.top = tile_rect.bottom
                        player_vel_y = 0

            if keys[pygame.K_SPACE] and on_ground:
                player_vel_y = -JUMP_STRENGTH

            for enemy in enemies:
                enemy['rect'].x += enemy['dir']
                if abs(enemy['rect'].x - enemy['origin_x']) >= TILE_SIZE:
                    enemy['dir'] *= -1

            for i, tile in enumerate(level):
                tile_x = i * TILE_SIZE
                tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
                if tile == 'lava':
                    lava_rect = pygame.Rect(tile_x, tile_y + TILE_SIZE // 2, TILE_SIZE, TILE_SIZE // 2)
                    if player.colliderect(lava_rect):
                        if not bubbles_animating :
                            bubbles_animating = True
                            # Reset bubbles for fresh animation
                            for bubble in bubbles:
                                bubble.reset()
                        dead = True

                elif tile == 'spike':
                    spike_rect = pygame.Rect(tile_x, tile_y - TILE_SIZE, TILE_SIZE, TILE_SIZE * 2)
                    if player.colliderect(spike_rect):
                        # Trigger shatter animation on spike collision
                        if not shatter_animating:
                            shatter_animating = True
                            particles.clear()
                            particle_size = TILE_SIZE // 4  # e.g. 6 if TILE_SIZE=24
                            px = player.x
                            py = player.y
                            for i_ in range(0, TILE_SIZE, particle_size):
                                for j_ in range(0, TILE_SIZE, particle_size):
                                    particles.append(Particle(px + i_, py + j_, particle_size))
                        dead = True

            for enemy in enemies:
                if player.colliderect(enemy['rect']):
                    dead = True

            if player.y > SCREEN_HEIGHT:
                dead = True

            end_x = (len(level) - 1) * TILE_SIZE
            if player.x >= end_x:
                level = generate_level() #BOB
                levels_completed += 1
                if levels_completed == 20:
                    my_folder = os.path.abspath(os.path.dirname(__file__))
                    pic_location = os.path.join(my_folder, 'Cryon_bg.png')
                    bgso = pygame.image.load(pic_location)
                    bgso = pygame.transform.scale(bgso, (SCREEN_WIDTH, SCREEN_HEIGHT))
                    
                LEVEL_WIDTH = len(level) * TILE_SIZE
                player = find_starting_block()
                spawn_enemies()
                scroll_x = 0
                continue

            player.x = max(0, min(player.x, LEVEL_WIDTH - TILE_SIZE))
            scroll_x = player.x - SCREEN_WIDTH // 2
            scroll_x = max(0, min(scroll_x, LEVEL_WIDTH - SCREEN_WIDTH))

    for i, tile in enumerate(level):
        tile_x = i * TILE_SIZE - scroll_x
        tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
        if tile_x + TILE_SIZE < 0 or tile_x > SCREEN_WIDTH:
            continue
        if tile == 'block':
            screen.blit(block_surf, (tile_x, tile_y))
        elif tile == 'lava':
            screen.blit(lava_surf, (tile_x, tile_y))
        elif tile == 'spike':
            screen.blit(spike_surf, (tile_x, tile_y -32))
        elif tile == 'tall_block':
            screen.blit(tall_block_surf, (tile_x, tile_y - TILE_SIZE))
        elif tile == 'start':
            screen.blit(start_surf, (tile_x, tile_y))
        elif tile == 'end':
            screen.blit(end_surf, (tile_x, tile_y))

    for enemy in enemies:
        screen.blit(enemy_surf, (enemy['rect'].x - scroll_x, enemy['rect'].y))

    player_screen_x = player.x - scroll_x
    if not dead or (show_player and not shatter_animating):
        screen.blit(player1_surf, [player_screen_x, player.y])

    if dead and not shatter_animating:
        fade_surface.set_alpha(fade_alpha)
        screen.blit(fade_surface, (0, 0))

    pygame.display.flip()

pygame.quit()
sys.exit()
