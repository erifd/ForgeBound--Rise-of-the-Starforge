# import torch
import random
import pygame
import sys
import os
import hashlib
import event_manager as em
import Storyline

random.seed()

# Init bg
bg_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Background")
pic_location = os.path.join(bg_folder, 'Solarite_bg.png')
bgso = pygame.image.load(pic_location)

pygame.init()
result = Storyline.run_storyline()
if result == "done":
    print("Switching to platformer...")

SCREEN_WIDTH = 500
SCREEN_HEIGHT = 320
TILE_SIZE = 24
GROUND_Y_OFFSET = 15

bgso = pygame.transform.scale(bgso, (SCREEN_WIDTH, SCREEN_HEIGHT))

GRAVITY = 1.156789123456789123456789
JUMP_STRENGTH = 16.456
player_speed = 4

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Forgebound: Rise of the Starforge")
solarite_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Solarite")
cryon_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Cryon")
voidstone_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Voidstone")
gravium_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Gravium")
toxic_swamps_terrain_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Terrain", "Toxic Swamps")
player_folder = os.path.join(os.path.abspath(os.path.dirname(__file__)), "Assets", "Player", "Normal")

# INIT PLAYER1
player1_location = os.path.join(player_folder, 'player1.png')
player1_img = pygame.image.load(player1_location).convert_alpha()
player1_img = pygame.transform.scale(player1_img, (TILE_SIZE, TILE_SIZE*2))
player1_surf = player1_img

# Normal block
block1_location = os.path.join(solarite_terrain_folder, 'normal_block_solarite.png')
block_img = pygame.image.load(block1_location).convert_alpha()
block_img = pygame.transform.scale(block_img, (TILE_SIZE, TILE_SIZE))
block_surf = block_img

# Lava
lava_location = os.path.join(solarite_terrain_folder, 'lava_block.png')
lava_img = pygame.image.load(lava_location).convert_alpha()
lava_img = pygame.transform.scale(lava_img, (32, 16))
lava_surf = lava_img

# Spike
spike_loc = os.path.join(solarite_terrain_folder, 'spike_solarite.png')
spike_img = pygame.image.load(spike_loc).convert_alpha()
spike_img = pygame.transform.scale(spike_img, (TILE_SIZE, TILE_SIZE * 2))
spike_surf = spike_img

tall_block_surf = pygame.Surface((TILE_SIZE, TILE_SIZE * 2)); tall_block_surf.fill((100, 255, 100))
enemy_surf = pygame.Surface((TILE_SIZE, TILE_SIZE)); enemy_surf.fill((255, 0, 255))
start_surf = pygame.Surface((TILE_SIZE, TILE_SIZE)); start_surf.fill((0, 255, 255))
end_surf = pygame.Surface((TILE_SIZE, TILE_SIZE)); end_surf.fill((255, 255, 0))

TERRAIN = ['block', 'lava', 'spike', 'tall_block', 'enemy']
SEQUENCE_LENGTH = 20
levels_completed = 0

# Font for mouse coordinates
font = pygame.font.Font(None, 24)

# Red dot indicator - represents player on the pyramid path
RED_DOT_RADIUS = 5

# Define the pyramid path coordinates (x, y) for the red dot to follow
PYRAMID_PATH = [
    (40, 285), (60, 275), (80, 265), (100, 255), (120, 245),
    (140, 235),
    (160, 225),
    (180, 215), (200, 205), (220, 195), (240, 185),
    (260, 175), (280, 165), (300, 155),
    (120, 145),
    (320, 135),
    (380, 125),
    (340, 115),
    (320, 105),
    (300, 95), (280, 85), (260, 75), (240, 65), (220, 55), (200, 45),
]

# Save code system
class SaveCodeSystem:
    SECRET_SALT = "FORGEBOUND_STARFORGE_2025"
    USERS_FILE = os.path.join(os.path.dirname(__file__), "..", "platformer-auth-backend", "users.txt")
    
    @staticmethod
    def generate_save_code(levels_completed):
        data = f"{levels_completed}"
        hash_input = f"{data}{SaveCodeSystem.SECRET_SALT}".encode('utf-8')
        checksum = hashlib.sha256(hash_input).hexdigest()[:4].upper()
        save_code = f"{levels_completed}-{checksum}"
        return save_code
    
    @staticmethod
    def validate_save_code(save_code):
        try:
            parts = save_code.strip().upper().split('-')
            if len(parts) != 2:
                return None
            
            levels_str, provided_checksum = parts
            levels_completed = int(levels_str)
            
            if levels_completed < 0 or levels_completed > 20:
                return None
            
            hash_input = f"{levels_completed}{SaveCodeSystem.SECRET_SALT}".encode('utf-8')
            correct_checksum = hashlib.sha256(hash_input).hexdigest()[:4].upper()
            
            if provided_checksum != correct_checksum:
                return None
            
            return levels_completed
            
        except (ValueError, IndexError):
            return None
    
    @staticmethod
    def save_to_users_file(username, save_code):
        """Save the username and their save code to users.txt"""
        try:
            users_file = SaveCodeSystem.USERS_FILE
            
            # Read existing users
            users = {}
            if os.path.exists(users_file):
                with open(users_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if ':' in line:
                            parts = line.split(':', 2)  # Split into at most 3 parts
                            if len(parts) >= 2:
                                user = parts[0]
                                password = parts[1]
                                # Check if there's a save code
                                existing_save = parts[2] if len(parts) == 3 else ""
                                users[user] = {'password': password, 'save': existing_save}
            
            # Update or add the user's save code
            if username in users:
                users[username]['save'] = save_code
            else:
                # New user - no password stored (guest mode)
                users[username] = {'password': '', 'save': save_code}
            
            # Write back to file
            with open(users_file, 'w') as f:
                for user, data in users.items():
                    if data['save']:
                        f.write(f"{user}:{data['password']}:{data['save']}\n")
                    else:
                        f.write(f"{user}:{data['password']}\n")
            
            return True
        except Exception as e:
            print(f"Error saving to users.txt: {e}")
            return False
    
    @staticmethod
    def load_from_users_file(username):
        """Load a user's save code from users.txt"""
        try:
            users_file = SaveCodeSystem.USERS_FILE
            
            if not os.path.exists(users_file):
                return None
            
            with open(users_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if ':' in line:
                        parts = line.split(':', 2)
                        if len(parts) >= 3 and parts[0] == username:
                            return parts[2]  # Return save code
            
            return None
        except Exception as e:
            print(f"Error loading from users.txt: {e}")
            return None

def show_save_code_dialog(screen, font, levels_completed, username=None):
    save_code = SaveCodeSystem.generate_save_code(levels_completed)
    
    # Save to users.txt if username provided
    if username:
        SaveCodeSystem.save_to_users_file(username, save_code)
    
    overlay = pygame.Surface((screen.get_width(), screen.get_height()))
    overlay.fill((0, 0, 0))
    overlay.set_alpha(180)
    screen.blit(overlay, (0, 0))
    
    dialog_width = 400
    dialog_height = 180
    dialog_x = (screen.get_width() - dialog_width) // 2
    dialog_y = (screen.get_height() - dialog_height) // 2
    
    pygame.draw.rect(screen, (50, 50, 50), (dialog_x, dialog_y, dialog_width, dialog_height))
    pygame.draw.rect(screen, (255, 255, 255), (dialog_x, dialog_y, dialog_width, dialog_height), 3)
    
    title_text = font.render("YOUR SAVE CODE", True, (255, 255, 0))
    title_rect = title_text.get_rect(center=(screen.get_width() // 2, dialog_y + 30))
    screen.blit(title_text, title_rect)
    
    code_font = pygame.font.Font(None, 48)
    code_text = code_font.render(save_code, True, (0, 255, 0))
    code_rect = code_text.get_rect(center=(screen.get_width() // 2, dialog_y + 75))
    screen.blit(code_text, code_rect)
    
    inst_text = font.render("Write this down! Press ESC to close", True, (200, 200, 200))
    inst_rect = inst_text.get_rect(center=(screen.get_width() // 2, dialog_y + 120))
    screen.blit(inst_text, inst_rect)
    
    # Show if saved to file
    if username:
        saved_text = font.render(f"Saved for user: {username}", True, (100, 255, 100))
        saved_rect = saved_text.get_rect(center=(screen.get_width() // 2, dialog_y + 145))
        screen.blit(saved_text, saved_rect)
    
    pygame.display.flip()
    
    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    waiting = False
    return True

def show_load_code_dialog(screen, font):
    input_text = ""
    clock = pygame.time.Clock()
    entering = True
    
    while entering:
        clock.tick(60)
        
        overlay = pygame.Surface((screen.get_width(), screen.get_height()))
        overlay.fill((0, 0, 0))
        overlay.set_alpha(180)
        screen.blit(overlay, (0, 0))
        
        dialog_width = 400
        dialog_height = 180
        dialog_x = (screen.get_width() - dialog_width) // 2
        dialog_y = (screen.get_height() - dialog_height) // 2
        
        pygame.draw.rect(screen, (50, 50, 50), (dialog_x, dialog_y, dialog_width, dialog_height))
        pygame.draw.rect(screen, (255, 255, 255), (dialog_x, dialog_y, dialog_width, dialog_height), 3)
        
        title_text = font.render("ENTER SAVE CODE", True, (255, 255, 0))
        title_rect = title_text.get_rect(center=(screen.get_width() // 2, dialog_y + 30))
        screen.blit(title_text, title_rect)
        
        input_box = pygame.Rect(dialog_x + 50, dialog_y + 70, dialog_width - 100, 40)
        pygame.draw.rect(screen, (30, 30, 30), input_box)
        pygame.draw.rect(screen, (255, 255, 255), input_box, 2)
        
        input_surface = font.render(input_text, True, (255, 255, 255))
        screen.blit(input_surface, (input_box.x + 10, input_box.y + 10))
        
        inst_text = font.render("Press ENTER to load, ESC to cancel", True, (200, 200, 200))
        inst_rect = inst_text.get_rect(center=(screen.get_width() // 2, dialog_y + 145))
        screen.blit(inst_text, inst_rect)
        
        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return None
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return None
                elif event.key == pygame.K_RETURN:
                    levels = SaveCodeSystem.validate_save_code(input_text)
                    if levels is not None:
                        return levels
                    else:
                        error_text = font.render("INVALID CODE!", True, (255, 0, 0))
                        error_rect = error_text.get_rect(center=(screen.get_width() // 2, dialog_y + 120))
                        screen.blit(error_text, error_rect)
                        pygame.display.flip()
                        pygame.time.wait(1000)
                        input_text = ""
                elif event.key == pygame.K_BACKSPACE:
                    input_text = input_text[:-1]
                else:
                    if event.unicode.isalnum() or event.unicode == '-':
                        if len(input_text) < 10:
                            input_text += event.unicode.upper()
    
    return None

def generate_level():
    level = [''] * SEQUENCE_LENGTH
    level[0] = 'start'
    level[-1] = 'end'
    count = 0

    while True:
        start = random.randint(1, SEQUENCE_LENGTH - 4)
        if all(level[start + i] == '' for i in range(3)):
            for i in range(3):
                level[start + i] = 'block'
                count += 1
            break

    while True:
        start = random.randint(1, SEQUENCE_LENGTH - 4)
        if all(cell == '' for cell in level[start:start + 3]):
            for i in range(3):
                level[start + i] = 'tall_block'
            break

    num_lava = random.randint(2, 4)
    while True:
        start = random.randint(1, SEQUENCE_LENGTH - num_lava - 1)
        if all(level[start + i] == '' for i in range(num_lava)):
            for i in range(num_lava):
                level[start + i] = 'lava'
            break

    num_spikes = random.randint(1, 4)
    attempts = 0
    while attempts < 50:
        start = random.randint(1, SEQUENCE_LENGTH - num_spikes - 1)
        if all(level[start + i] == '' for i in range(num_spikes)):
            if num_spikes == 4:
                has_tall_block_before = any(level[i] == 'tall_block' for i in range(max(0, start - 3), start))
                left_is_ground = start > 0 and level[start - 1] == ''
                right_is_ground = start + num_spikes < SEQUENCE_LENGTH and level[start + num_spikes] == ''
                
                if left_is_ground and right_is_ground and not has_tall_block_before:
                    attempts += 1
                    continue
            
            for i in range(num_spikes):
                level[start + i] = 'spike'
            break
        attempts += 1

    for i in range(SEQUENCE_LENGTH):
        if level[i] == '':
            level[i] = 'block'
            count += 1

    max_enemies = count // 3
    enemy_count = 0
    attempts = 0

    def is_enemy_nearby(level, pos, range_=2):
        start = max(0, pos - range_)
        end = min(SEQUENCE_LENGTH, pos + range_ + 1)
        return any(level[i] == 'enemy' for i in range(start, end) if i != pos)
    
    def has_spikes_before(level, pos, range_=4):
        spike_count = 0
        for i in range(max(0, pos - range_), pos):
            if level[i] == 'spike':
                spike_count += 1
        return spike_count >= 4

    while enemy_count < max_enemies and attempts < 100:
        pos = random.randint(3, SEQUENCE_LENGTH - 3)
        if (level[pos] == 'block' and
            level[pos - 1] == 'block' and
            level[pos + 1] == 'block' and
            not is_enemy_nearby(level, pos, range_=2) and
            not has_spikes_before(level, pos, range_=4)):
            level[pos] = 'enemy'
            enemy_count += 1
        attempts += 1

    return level

def find_starting_block():
    tile_x = 0
    tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
    player_rect = pygame.Rect(tile_x, tile_y - TILE_SIZE * 2, TILE_SIZE, TILE_SIZE * 2)
    player_rect.bottom = tile_y
    return player_rect

def spawn_enemies():
    enemies.clear()
    enemy_positions = []
    for i, tile in enumerate(level):
        if tile == 'enemy':
            enemy_positions.append(i)
            level[i] = 'block'
    
    for i in enemy_positions:
        x = i * TILE_SIZE
        tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
        enemy_rect = pygame.Rect(x, tile_y - TILE_SIZE, TILE_SIZE, TILE_SIZE)
        enemy_rect.bottom = tile_y
        enemies.append({
            'rect': enemy_rect, 
            'dir': random.choice([-1, 1]), 
            'origin_x': x, 
            'pause_timer': random.randint(0, 60),
            'offset': random.randint(0, TILE_SIZE)
        })

class Particle:
    def __init__(self, x, y, size):
        self.rect = pygame.Rect(x, y, size, size)
        self.vel_x = random.uniform(-4, 4)
        self.vel_y = random.uniform(-8, -2)
        self.size = size
        self.lifetime = 60
        self.gravity = 0.5

    def update(self):
        self.vel_y += self.gravity
        self.rect.x += int(self.vel_x)
        self.rect.y += int(self.vel_y)

        floor_y = SCREEN_HEIGHT - GROUND_Y_OFFSET
        if self.rect.bottom >= floor_y:
            self.rect.bottom = floor_y
            self.vel_y = -self.vel_y * 0.6
            self.vel_x *= 0.8

        self.lifetime -= 1

    def draw(self, surface):
        pygame.draw.rect(surface, (255, 124, 200), self.rect)

particles = []
shatter_animating = False

enemy_death_animating = False
enemy_death_timer = 0
death_enemy_pos = None
enemy_rush_offset = 0
slash_reveal = 0
enemy_trail = []
ENEMY_DEATH_DURATION = 120
RUSH_DURATION = 20
CUT_DURATION = 40

class Bubble:
    def __init__(self, min_x, max_x):
        self.min_x = min_x
        self.max_x = max_x
        self.reset()

    def reset(self):
        self.x = random.randint(self.min_x, self.max_x)
        self.y = random.randint(SCREEN_HEIGHT, SCREEN_HEIGHT + 200)
        self.radius = random.randint(3, 6)
        self.speed = random.uniform(1, 2)
        self.color = random.choice(BUBBLE_COLORS)

    def update(self):
        self.y -= self.speed
        if self.y + self.radius < 0:
            self.reset()

    def draw(self, surface):
        pygame.draw.circle(surface, self.color, (int(self.x), int(self.y)), self.radius)

BUBBLE_COLORS = [(255, 223, 0), (255, 165, 0)]
bubbles = []
bubbles_animating = False
bubble_timer = 0
BUBBLE_DURATION = 150

level = generate_level()
LEVEL_WIDTH = len(level) * TILE_SIZE
enemies = []
spawn_enemies()
player = find_starting_block()
player_vel_y = 0
on_ground = False
scroll_x = 0
dead = False
death_phase = None
death_timer = 0
fade_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
fade_surface.fill((0, 0, 0))
fade_alpha = 0
show_player = True

# Save/Load dialog flags
show_save_dialog = False
show_load_dialog = False
current_username = None  # Store username from launcher

# Check for username from command line argument (passed by launcher)
if len(sys.argv) > 1:
    current_username = sys.argv[1]
    # Try to load saved progress for this user
    saved_code = SaveCodeSystem.load_from_users_file(current_username)
    if saved_code:
        loaded_levels = SaveCodeSystem.validate_save_code(saved_code)
        if loaded_levels is not None:
            levels_completed = loaded_levels
            print(f"Loaded progress for {current_username}: Level {loaded_levels}")
            if levels_completed >= 20:
                pic_location = os.path.join(bg_folder, 'Cryon_bg.png')
                bgso = pygame.image.load(pic_location)
                bgso = pygame.transform.scale(bgso, (SCREEN_WIDTH, SCREEN_HEIGHT))

clock = pygame.time.Clock()
running = True
while running:
    clock.tick(60)
    screen.blit(bgso, [0, 0])

    mouse_x, mouse_y = pygame.mouse.get_pos()

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    keys = pygame.key.get_pressed()
    
    # Check for Ctrl+S (save) and Ctrl+L (load)
    if keys[pygame.K_LCTRL] or keys[pygame.K_RCTRL]:
        if keys[pygame.K_s]:
            show_save_dialog = True
        if keys[pygame.K_l]:
            show_load_dialog = True

    if shatter_animating:
        fade_surface.set_alpha(150)
        screen.blit(fade_surface, (0, 0))

        for p in particles[:]:
            p.update()
            p.draw(screen)
            if p.lifetime <= 0:
                particles.remove(p)

        if not particles:
            shatter_animating = False
            dead = False
            player = find_starting_block()
            player_vel_y = 0
            scroll_x = 0
            continue

    if enemy_death_animating:
        screen.fill((0, 0, 0))

        player_screen_x = player.x - scroll_x
        
        if enemy_death_timer < RUSH_DURATION:
            progress = enemy_death_timer / RUSH_DURATION
            start_x = player_screen_x + TILE_SIZE * 4
            enemy_rush_offset = progress * (TILE_SIZE * 4)
            current_enemy_x = start_x - enemy_rush_offset
            
            enemy_trail.append((current_enemy_x, death_enemy_pos[1] if death_enemy_pos else player.y))
            if len(enemy_trail) > 8:
                enemy_trail.pop(0)
            
            for i, (trail_x, trail_y) in enumerate(enemy_trail):
                alpha = int((i / len(enemy_trail)) * 255)
                trail_surf = enemy_surf.copy()
                trail_surf.set_alpha(alpha)
                orange_overlay = pygame.Surface((TILE_SIZE, TILE_SIZE))
                orange_overlay.fill((255, 140, 0))
                trail_surf.blit(orange_overlay, (0, 0), special_flags=pygame.BLEND_MULT)
                screen.blit(trail_surf, (trail_x, trail_y))
            
            if death_enemy_pos:
                screen.blit(enemy_surf, (current_enemy_x, death_enemy_pos[1]))
            
            screen.blit(player1_surf, [player_screen_x, player.y])
        
        elif enemy_death_timer < RUSH_DURATION + CUT_DURATION:
            for i, (trail_x, trail_y) in enumerate(enemy_trail):
                alpha = int((i / len(enemy_trail)) * 200)
                trail_surf = enemy_surf.copy()
                trail_surf.set_alpha(alpha)
                orange_overlay = pygame.Surface((TILE_SIZE, TILE_SIZE))
                orange_overlay.fill((255, 140, 0))
                trail_surf.blit(orange_overlay, (0, 0), special_flags=pygame.BLEND_MULT)
                screen.blit(trail_surf, (trail_x, trail_y))
            
            slash_reveal = ((enemy_death_timer - RUSH_DURATION) / CUT_DURATION)
            
            screen.blit(player1_surf, [player_screen_x, player.y])
            
            cut_height = int(TILE_SIZE * 2 * slash_reveal)
            for y in range(0, cut_height, 3):
                x_offset = int((y / (TILE_SIZE * 2)) * (TILE_SIZE * 1.5))
                for x in range(-4, 12, 3):
                    pygame.draw.rect(screen, (255, 255, 255), 
                                   (player_screen_x + x_offset + x, player.y + y, 3, 3))
        
        else:
            screen.blit(player1_surf, [player_screen_x, player.y])
            
            for y in range(0, TILE_SIZE * 2, 3):
                x_offset = int((y / (TILE_SIZE * 2)) * (TILE_SIZE * 1.5))
                for x in range(-4, 12, 3):
                    pygame.draw.rect(screen, (255, 255, 255), 
                                   (player_screen_x + x_offset + x, player.y + y, 3, 3))
        
        enemy_death_timer += 1
        
        if enemy_death_timer >= ENEMY_DEATH_DURATION:
            enemy_death_animating = False
            enemy_death_timer = 0
            enemy_rush_offset = 0
            slash_reveal = 0
            death_enemy_pos = None
            enemy_trail.clear()
            dead = False
            player = find_starting_block()
            player_vel_y = 0
            scroll_x = 0
            continue

    if bubbles_animating:
        fade_surface.set_alpha(150)
        screen.blit(fade_surface, (0, 0))

        for bubble in bubbles:
            bubble.update()
            bubble.draw(screen)

        bubble_timer += 1
        if bubble_timer >= BUBBLE_DURATION:
            bubbles_animating = False
            bubbles.clear()
            bubble_timer = 0
            dead = False
            player = find_starting_block()
            player_vel_y = 0
            scroll_x = 0
            continue

    if not shatter_animating and not bubbles_animating and not enemy_death_animating:
        if dead:
            player_vel_y = 0
            death_timer += 1

            if death_phase is None:
                death_phase = 'fade'
                death_timer = 0
                fade_alpha = 0

            if death_phase == 'fade':
                fade_alpha = min(255, fade_alpha + 10)
                if fade_alpha >= 255:
                    death_phase = 'pause'
                    death_timer = 0

            elif death_phase == 'pause':
                if death_timer >= 30:
                    death_phase = 'scroll'
                    death_timer = 0
                    fade_alpha = 255

            elif death_phase == 'scroll':
                scroll_x -= 5
                scroll_x = max(0, scroll_x)
                show_player = (death_timer // 5) % 2 == 0
                if scroll_x == 0:
                    death_phase = 'reset'
                    death_timer = 0

            elif death_phase == 'reset':
                player = find_starting_block()
                player_vel_y = 0
                dead = False
                death_phase = None
                death_timer = 0
                show_player = True

        else:
            move_x = 0
            if keys[pygame.K_LEFT]:
                move_x = -player_speed
            if keys[pygame.K_RIGHT]:
                move_x = player_speed

            player.x += move_x
            player.y += player_vel_y
            player_vel_y += GRAVITY
            on_ground = False

            for i, tile in enumerate(level):
                tile_x = i * TILE_SIZE
                tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
                if tile in ('block', 'start', 'end'):
                    tile_rect = pygame.Rect(tile_x, tile_y, TILE_SIZE, TILE_SIZE)
                elif tile == 'tall_block':
                    tile_rect = pygame.Rect(tile_x, tile_y - TILE_SIZE, TILE_SIZE, TILE_SIZE * 2)
                else:
                    continue
                if player.colliderect(tile_rect):
                    if player_vel_y > 0 and player.bottom <= tile_rect.top + player_vel_y:
                        player.bottom = tile_rect.top
                        player_vel_y = 0
                        on_ground = True
                    elif player_vel_y < 0 and player.top >= tile_rect.bottom - player_vel_y:
                        player.top = tile_rect.bottom
                        player_vel_y = 0

            if keys[pygame.K_SPACE] and on_ground:
                player_vel_y = -JUMP_STRENGTH

            for enemy in enemies:
                if enemy['pause_timer'] > 0:
                    enemy['pause_timer'] -= 1
                else:
                    enemy['rect'].x += enemy['dir']
                    distance_from_origin = abs(enemy['rect'].x - enemy['origin_x'])
                    if distance_from_origin >= TILE_SIZE:
                        enemy['dir'] *= -1
                        enemy['pause_timer'] = 60

            lava_sections = []
            in_lava = False
            start_idx = 0
            for i, tile in enumerate(level):
                if tile == 'lava':
                    if not in_lava:
                        start_idx = i
                        in_lava = True
                else:
                    if in_lava:
                        lava_sections.append((start_idx, i - 1))
                        in_lava = False
            if in_lava:
                lava_sections.append((start_idx, len(level) - 1))

            for i, tile in enumerate(level):
                tile_x = i * TILE_SIZE
                tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
                if tile == 'lava':
                    lava_rect = pygame.Rect(tile_x, tile_y + TILE_SIZE // 2, TILE_SIZE, TILE_SIZE // 2)
                    if player.colliderect(lava_rect):
                        if not bubbles_animating:
                            bubbles_animating = True
                            bubble_timer = 0
                            bubbles.clear()
                            
                            for start_idx, end_idx in lava_sections:
                                if start_idx <= i <= end_idx:
                                    lava_start_x = start_idx * TILE_SIZE
                                    lava_end_x = (end_idx + 1) * TILE_SIZE
                                    for _ in range(40):
                                        bubbles.append(Bubble(lava_start_x, lava_end_x))
                                    break
                        dead = True

                elif tile == 'spike':
                    spike_rect = pygame.Rect(tile_x, tile_y - TILE_SIZE, TILE_SIZE, TILE_SIZE * 2)
                    if player.colliderect(spike_rect):
                        if not shatter_animating:
                            shatter_animating = True
                            particles.clear()
                            particle_size = TILE_SIZE // 4
                            px = player.x
                            py = player.y
                            for i_ in range(0, TILE_SIZE, particle_size):
                                for j_ in range(0, TILE_SIZE, particle_size):
                                    particles.append(Particle(px + i_, py + j_, particle_size))
                        dead = True

            for enemy in enemies:
                if player.colliderect(enemy['rect']):
                    if not enemy_death_animating:
                        enemy_death_animating = True
                        enemy_death_timer = 0
                        enemy_rush_offset = 0
                        slash_reveal = 0
                        death_enemy_pos = (enemy['rect'].x, enemy['rect'].y)
                    dead = True

            if player.y > SCREEN_HEIGHT:
                dead = True

            end_x = (len(level) - 1) * TILE_SIZE
            if player.x >= end_x:
                level = generate_level()
                levels_completed += 1
                if levels_completed == 20:
                    my_folder = os.path.abspath(os.path.dirname(__file__))
                    pic_location = os.path.join(my_folder, 'Cryon_bg.png')
                    bgso = pygame.image.load(pic_location)
                    bgso = pygame.transform.scale(bgso, (SCREEN_WIDTH, SCREEN_HEIGHT))
                    
                LEVEL_WIDTH = len(level) * TILE_SIZE
                spawn_enemies()
                player = find_starting_block()
                scroll_x = 0
                player_vel_y = 0
                continue

            player.x = max(0, min(player.x, LEVEL_WIDTH - TILE_SIZE))
            scroll_x = player.x - SCREEN_WIDTH // 2
            scroll_x = max(0, min(scroll_x, LEVEL_WIDTH - SCREEN_WIDTH))

    for i, tile in enumerate(level):
        tile_x = i * TILE_SIZE - scroll_x
        tile_y = SCREEN_HEIGHT - TILE_SIZE - GROUND_Y_OFFSET
        if tile_x + TILE_SIZE < 0 or tile_x > SCREEN_WIDTH:
            continue
        if tile == 'block':
            screen.blit(block_surf, (tile_x, tile_y))
        elif tile == 'lava':
            screen.blit(lava_surf, (tile_x, tile_y))
        elif tile == 'spike':
            screen.blit(spike_surf, (tile_x, tile_y -32))
        elif tile == 'tall_block':
            screen.blit(tall_block_surf, (tile_x, tile_y - TILE_SIZE))
        elif tile == 'start':
            screen.blit(start_surf, (tile_x, tile_y))
        elif tile == 'end':
            screen.blit(end_surf, (tile_x, tile_y))

    for enemy in enemies:
        screen.blit(enemy_surf, (enemy['rect'].x - scroll_x, enemy['rect'].y))

    player_screen_x = player.x - scroll_x
    if not dead or (show_player and not shatter_animating):
        screen.blit(player1_surf, [player_screen_x, player.y])

    if dead and not shatter_animating and not bubbles_animating and not enemy_death_animating:
        fade_surface.set_alpha(fade_alpha)
        screen.blit(fade_surface, (0, 0))

    coord_text = font.render(f"X: {mouse_x}, Y: {mouse_y}", True, (255, 255, 255))
    text_rect = coord_text.get_rect(topleft=(5, 5))
    
    bg_rect = pygame.Rect(text_rect.x - 2, text_rect.y - 2, text_rect.width + 4, text_rect.height + 4)
    pygame.draw.rect(screen, (0, 0, 0), bg_rect)
    
    screen.blit(coord_text, (5, 5))

    path_segments_per_level = len(PYRAMID_PATH) / 20
    dot_index = int(levels_completed * path_segments_per_level)
    dot_index = min(dot_index, len(PYRAMID_PATH) - 1)
    
    current_level_progress = player.x / LEVEL_WIDTH
    next_dot_index = min(dot_index + 1, len(PYRAMID_PATH) - 1)
    
    current_point = PYRAMID_PATH[dot_index]
    next_point = PYRAMID_PATH[next_dot_index]
    
    dot_x = current_point[0] + (next_point[0] - current_point[0]) * current_level_progress
    dot_y = current_point[1] + (next_point[1] - current_point[1]) * current_level_progress
    
    pygame.draw.circle(screen, (255, 0, 0), (int(dot_x), int(dot_y)), RED_DOT_RADIUS)

    # Handle save/load dialogs BEFORE pygame.display.flip()
    if show_save_dialog:
        if show_save_code_dialog(screen, font, levels_completed):
            show_save_dialog = False
        else:
            running = False

    if show_load_dialog:
        loaded_levels = show_load_code_dialog(screen, font)
        if loaded_levels is not None:
            levels_completed = loaded_levels
            if levels_completed >= 20:
                pic_location = os.path.join(bg_folder, 'Cryon_bg.png')
                bgso = pygame.image.load(pic_location)
                bgso = pygame.transform.scale(bgso, (SCREEN_WIDTH, SCREEN_HEIGHT))
        show_load_dialog = False

    pygame.display.flip()

pygame.quit()
sys.exit()